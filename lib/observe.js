// https://libs.gullerya.com/object-observer/4.3.2/object-observer.js
// last tested working version: 4.3.2 (added 25.9.2021)
// self-minified version in the esbuild playground (https://esbuild.egoist.dev/) due to the pre-minified version mangling variable names
"use strict";
var INSERT="insert";var UPDATE="update";var DELETE="delete";var REVERSE="reverse";var SHUFFLE="shuffle";var oMetaKey=Symbol.for("object-observer-meta-key-0");var validObservableOptionKeys={async:1};var processObserveOptions=options=>{if(!options||typeof options!=="object"){return null}const result={};const invalidOptions=[];for(const[optName,optVal]of Object.entries(options)){if(optName==="path"){if(typeof optVal!=="string"||optVal===""){throw new Error('"path" option, if/when provided, MUST be a non-empty string')}result[optName]=optVal}else if(optName==="pathsOf"){if(options.path){throw new Error('"pathsOf" option MAY NOT be specified together with "path" option')}if(typeof optVal!=="string"){throw new Error('"pathsOf" option, if/when provided, MUST be a string (MAY be empty)')}result[optName]=options.pathsOf.split(".").filter(Boolean)}else if(optName==="pathsFrom"){if(options.path||options.pathsOf){throw new Error('"pathsFrom" option MAY NOT be specified together with "path"/"pathsOf"  option/s')}if(typeof optVal!=="string"||optVal===""){throw new Error('"pathsFrom" option, if/when provided, MUST be a non-empty string')}result[optName]=optVal}else{invalidOptions.push(optName)}}if(invalidOptions.length){throw new Error(`'${invalidOptions.join(", ")}' is/are not a valid observer option/s`)}return result};var observe=function observe2(observer,options){if(typeof observer!=="function"){throw new Error(`observer MUST be a function, got '${observer}'`)}const observers=this[oMetaKey].observers;if(!observers.some(o=>o[0]===observer)){observers.push([observer,processObserveOptions(options)])}else{console.warn("observer may be bound to an observable only once; will NOT rebind")}};var unobserve=function unobserve2(){const observers=this[oMetaKey].observers;let ol=observers.length;if(ol){let al=arguments.length;if(al){while(al--){let i=ol;while(i--){if(observers[i][0]===arguments[al]){observers.splice(i,1);ol--}}}}else{observers.splice(0)}}};var propertiesBluePrint={[oMetaKey]:{value:null},observe:{value:observe},unobserve:{value:unobserve}};var prepareObject=(source,oMeta)=>{propertiesBluePrint[oMetaKey].value=oMeta;const target=Object.defineProperties({},propertiesBluePrint);for(const[key,value]of Object.entries(source)){target[key]=getObservedOf(value,key,oMeta)}return target};var prepareArray=(source,oMeta)=>{let i=0,l=source.length;propertiesBluePrint[oMetaKey].value=oMeta;const target=Object.defineProperties(new Array(l),propertiesBluePrint);for(;i<l;i++){target[i]=getObservedOf(source[i],i,oMeta)}return target};var prepareTypedArray=(source,oMeta)=>{propertiesBluePrint[oMetaKey].value=oMeta;Object.defineProperties(source,propertiesBluePrint);return source};var filterChanges=(options,changes)=>{let result=changes;if(options){if(options.path){const oPath=options.path;result=changes.filter(change=>change.path.join(".")===oPath)}else if(options.pathsOf){const oPathsOf=options.pathsOf;result=changes.filter(change=>change.path.length===oPathsOf.length+1||change.path.length===oPathsOf.length&&(change.type===REVERSE||change.type===SHUFFLE))}else if(options.pathsFrom){const oPathsFrom=options.pathsFrom;result=changes.filter(change=>change.path.join(".").startsWith(oPathsFrom))}}return result};var callObserverSafe=(listener,changes)=>{try{listener(changes)}catch(e){console.error(`failed to notify listener ${listener} with ${changes}`,e)}};var callObserversFromMT=function callObserversFromMT2(){const batches=this.batches;this.batches=null;for(const[listener,options]of batches){callObserverSafe(listener,options)}};var callObservers=(oMeta,changes)=>{let currentObservable=oMeta;let observers,target,options,relevantChanges,i,newPath,tmp;const l=changes.length;do{observers=currentObservable.observers;i=observers.length;while(i--){[target,options]=observers[i];relevantChanges=filterChanges(options,changes);if(relevantChanges.length){if(currentObservable.options.async){if(!currentObservable.batches){currentObservable.batches=[];queueMicrotask(callObserversFromMT.bind(currentObservable))}let rb;for(const b of currentObservable.batches){if(b[0]===target){rb=b;break}}if(!rb){rb=[target,[]];currentObservable.batches.push(rb)}Array.prototype.push.apply(rb[1],relevantChanges)}else{callObserverSafe(target,relevantChanges)}}}let tmpa;if(currentObservable.parent){tmpa=new Array(l);for(let j=0;j<l;j++){tmp=changes[j];newPath=[currentObservable.ownKey,...tmp.path];tmpa[j]={type:tmp.type,path:newPath,value:tmp.value,oldValue:tmp.oldValue,object:tmp.object}}changes=tmpa;currentObservable=currentObservable.parent}else{currentObservable=null}}while(currentObservable)};var getObservedOf=(item,key,parent)=>{if(!item||typeof item!=="object"){return item}else if(Array.isArray(item)){return new ArrayOMeta({target:item,ownKey:key,parent}).proxy}else if(ArrayBuffer.isView(item)){return new TypedArrayOMeta({target:item,ownKey:key,parent}).proxy}else if(item instanceof Date||item instanceof Blob||item instanceof Error){return item}else{return new ObjectOMeta({target:item,ownKey:key,parent}).proxy}};var proxiedPop=function proxiedPop2(){const oMeta=this[oMetaKey],target=oMeta.target,poppedIndex=target.length-1;let popResult=target.pop();if(popResult&&typeof popResult==="object"){const tmpObserved=popResult[oMetaKey];if(tmpObserved){popResult=tmpObserved.detach()}}const changes=[new Change(DELETE,[poppedIndex],void 0,popResult,this)];callObservers(oMeta,changes);return popResult};var proxiedPush=function proxiedPush2(){const oMeta=this[oMetaKey],target=oMeta.target,l=arguments.length,pushContent=new Array(l),initialLength=target.length;for(let i=0;i<l;i++){pushContent[i]=getObservedOf(arguments[i],initialLength+i,oMeta)}const pushResult=Reflect.apply(target.push,target,pushContent);const changes=[];for(let i=initialLength,j=target.length;i<j;i++){changes[i-initialLength]=new Change(INSERT,[i],target[i],void 0,this)}callObservers(oMeta,changes);return pushResult};var proxiedShift=function proxiedShift2(){const oMeta=this[oMetaKey],target=oMeta.target;let shiftResult,i,l,item,tmpObserved;shiftResult=target.shift();if(shiftResult&&typeof shiftResult==="object"){tmpObserved=shiftResult[oMetaKey];if(tmpObserved){shiftResult=tmpObserved.detach()}}for(i=0,l=target.length;i<l;i++){item=target[i];if(item&&typeof item==="object"){tmpObserved=item[oMetaKey];if(tmpObserved){tmpObserved.ownKey=i}}}const changes=[new Change(DELETE,[0],void 0,shiftResult,this)];callObservers(oMeta,changes);return shiftResult};var proxiedUnshift=function proxiedUnshift2(){const oMeta=this[oMetaKey],target=oMeta.target,al=arguments.length,unshiftContent=new Array(al);for(let i=0;i<al;i++){unshiftContent[i]=getObservedOf(arguments[i],i,oMeta)}const unshiftResult=Reflect.apply(target.unshift,target,unshiftContent);for(let i=0,l2=target.length,item;i<l2;i++){item=target[i];if(item&&typeof item==="object"){const tmpObserved=item[oMetaKey];if(tmpObserved){tmpObserved.ownKey=i}}}const l=unshiftContent.length;const changes=new Array(l);for(let i=0;i<l;i++){changes[i]=new Change(INSERT,[i],target[i],void 0,this)}callObservers(oMeta,changes);return unshiftResult};var proxiedReverse=function proxiedReverse2(){const oMeta=this[oMetaKey],target=oMeta.target;let i,l,item;target.reverse();for(i=0,l=target.length;i<l;i++){item=target[i];if(item&&typeof item==="object"){const tmpObserved=item[oMetaKey];if(tmpObserved){tmpObserved.ownKey=i}}}const changes=[new Change(REVERSE,[],void 0,void 0,this)];callObservers(oMeta,changes);return this};var proxiedSort=function proxiedSort2(comparator){const oMeta=this[oMetaKey],target=oMeta.target;let i,l,item;target.sort(comparator);for(i=0,l=target.length;i<l;i++){item=target[i];if(item&&typeof item==="object"){const tmpObserved=item[oMetaKey];if(tmpObserved){tmpObserved.ownKey=i}}}const changes=[new Change(SHUFFLE,[],void 0,void 0,this)];callObservers(oMeta,changes);return this};var proxiedFill=function proxiedFill2(filVal,start,end){const oMeta=this[oMetaKey],target=oMeta.target,changes=[],tarLen=target.length,prev=target.slice(0);start=start===void 0?0:start<0?Math.max(tarLen+start,0):Math.min(start,tarLen);end=end===void 0?tarLen:end<0?Math.max(tarLen+end,0):Math.min(end,tarLen);if(start<tarLen&&end>start){target.fill(filVal,start,end);let tmpObserved;for(let i=start,item,tmpTarget;i<end;i++){item=target[i];target[i]=getObservedOf(item,i,oMeta);if(i in prev){tmpTarget=prev[i];if(tmpTarget&&typeof tmpTarget==="object"){tmpObserved=tmpTarget[oMetaKey];if(tmpObserved){tmpTarget=tmpObserved.detach()}}changes.push(new Change(UPDATE,[i],target[i],tmpTarget,this))}else{changes.push(new Change(INSERT,[i],target[i],void 0,this))}}callObservers(oMeta,changes)}return this};var proxiedCopyWithin=function proxiedCopyWithin2(dest,start,end){const oMeta=this[oMetaKey],target=oMeta.target,tarLen=target.length;dest=dest<0?Math.max(tarLen+dest,0):dest;start=start===void 0?0:start<0?Math.max(tarLen+start,0):Math.min(start,tarLen);end=end===void 0?tarLen:end<0?Math.max(tarLen+end,0):Math.min(end,tarLen);const len=Math.min(end-start,tarLen-dest);if(dest<tarLen&&dest!==start&&len>0){const prev=target.slice(0),changes=[];target.copyWithin(dest,start,end);for(let i=dest,nItem,oItem,tmpObserved;i<dest+len;i++){nItem=target[i];if(nItem&&typeof nItem==="object"){nItem=getObservedOf(nItem,i,oMeta);target[i]=nItem}oItem=prev[i];if(oItem&&typeof oItem==="object"){tmpObserved=oItem[oMetaKey];if(tmpObserved){oItem=tmpObserved.detach()}}if(typeof nItem!=="object"&&nItem===oItem){continue}changes.push(new Change(UPDATE,[i],nItem,oItem,this))}callObservers(oMeta,changes)}return this};var proxiedSplice=function proxiedSplice2(){const oMeta=this[oMetaKey],target=oMeta.target,splLen=arguments.length,spliceContent=new Array(splLen),tarLen=target.length;for(let i2=0;i2<splLen;i2++){spliceContent[i2]=getObservedOf(arguments[i2],i2,oMeta)}const startIndex=splLen===0?0:spliceContent[0]<0?tarLen+spliceContent[0]:spliceContent[0],removed=splLen<2?tarLen-startIndex:spliceContent[1],inserted=Math.max(splLen-2,0),spliceResult=Reflect.apply(target.splice,target,spliceContent),newTarLen=target.length;let tmpObserved;for(let i2=0,item2;i2<newTarLen;i2++){item2=target[i2];if(item2&&typeof item2==="object"){tmpObserved=item2[oMetaKey];if(tmpObserved){tmpObserved.ownKey=i2}}}let i,l,item;for(i=0,l=spliceResult.length;i<l;i++){item=spliceResult[i];if(item&&typeof item==="object"){tmpObserved=item[oMetaKey];if(tmpObserved){spliceResult[i]=tmpObserved.detach()}}}const changes=[];let index;for(index=0;index<removed;index++){if(index<inserted){changes.push(new Change(UPDATE,[startIndex+index],target[startIndex+index],spliceResult[index],this))}else{changes.push(new Change(DELETE,[startIndex+index],void 0,spliceResult[index],this))}}for(;index<inserted;index++){changes.push(new Change(INSERT,[startIndex+index],target[startIndex+index],void 0,this))}callObservers(oMeta,changes);return spliceResult};var proxiedTypedArraySet=function proxiedTypedArraySet2(source,offset){const oMeta=this[oMetaKey],target=oMeta.target,souLen=source.length,prev=target.slice(0);offset=offset||0;target.set(source,offset);const changes=new Array(souLen);for(let i=offset;i<souLen+offset;i++){changes[i-offset]=new Change(UPDATE,[i],target[i],prev[i],this)}callObservers(oMeta,changes)};var proxiedArrayMethods={pop:proxiedPop,push:proxiedPush,shift:proxiedShift,unshift:proxiedUnshift,reverse:proxiedReverse,sort:proxiedSort,fill:proxiedFill,copyWithin:proxiedCopyWithin,splice:proxiedSplice};var proxiedTypedArrayMethods={reverse:proxiedReverse,sort:proxiedSort,fill:proxiedFill,copyWithin:proxiedCopyWithin,set:proxiedTypedArraySet};var Change=class{constructor(type,path,value,oldValue,object){this.type=type;this.path=path;this.value=value;this.oldValue=oldValue;this.object=object}};var OMetaBase=class{constructor(properties,cloningFunction){const{target,parent,ownKey}=properties;if(parent&&ownKey!==void 0){this.parent=parent;this.ownKey=ownKey}else{this.parent=null;this.ownKey=null}const targetClone=cloningFunction(target,this);this.observers=[];this.revocable=Proxy.revocable(targetClone,this);this.proxy=this.revocable.proxy;this.target=targetClone;this.options=this.processOptions(properties.options)}processOptions(options){if(options){if(typeof options!=="object"){throw new Error(`Observable options if/when provided, MAY only be an object, got '${options}'`)}const invalidOptions=Object.keys(options).filter(option=>!(option in validObservableOptionKeys));if(invalidOptions.length){throw new Error(`'${invalidOptions.join(", ")}' is/are not a valid Observable option/s`)}return Object.assign({},options)}else{return{}}}detach(){this.parent=null;return this.target}set(target,key,value){let oldValue=target[key];if(value!==oldValue){const newValue=getObservedOf(value,key,this);target[key]=newValue;if(oldValue&&typeof oldValue==="object"){const tmpObserved=oldValue[oMetaKey];if(tmpObserved){oldValue=tmpObserved.detach()}}const changes=oldValue===void 0?[new Change(INSERT,[key],newValue,void 0,this.proxy)]:[new Change(UPDATE,[key],newValue,oldValue,this.proxy)];callObservers(this,changes)}return true}deleteProperty(target,key){let oldValue=target[key];delete target[key];if(oldValue&&typeof oldValue==="object"){const tmpObserved=oldValue[oMetaKey];if(tmpObserved){oldValue=tmpObserved.detach()}}const changes=[new Change(DELETE,[key],void 0,oldValue,this.proxy)];callObservers(this,changes);return true}};var ObjectOMeta=class extends OMetaBase{constructor(properties){super(properties,prepareObject)}};var ArrayOMeta=class extends OMetaBase{constructor(properties){super(properties,prepareArray)}get(target,key){return proxiedArrayMethods[key]||target[key]}};var TypedArrayOMeta=class extends OMetaBase{constructor(properties){super(properties,prepareTypedArray)}get(target,key){return proxiedTypedArrayMethods[key]||target[key]}};var Observable=Object.freeze({from:(target,options)=>{if(!target||typeof target!=="object"){throw new Error("observable MAY ONLY be created from a non-null object")}else if(target[oMetaKey]){return target}else if(Array.isArray(target)){return new ArrayOMeta({target,ownKey:null,parent:null,options}).proxy}else if(ArrayBuffer.isView(target)){return new TypedArrayOMeta({target,ownKey:null,parent:null,options}).proxy}else if(target instanceof Date||target instanceof Blob||target instanceof Error){throw new Error(`${target} found to be one of a on-observable types`)}else{return new ObjectOMeta({target,ownKey:null,parent:null,options}).proxy}},isObservable:input=>{return!!(input&&input[oMetaKey])}});var callbackKey=Symbol("callback-key");var targetsKey=Symbol("targets-key");

